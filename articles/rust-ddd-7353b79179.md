---
title: 'api-server を Rust と DDD で実装する'
emoji: '🦍'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: [rust, axum, ddd, api]
published: false
---

## はじめに

rust と フレームワーク axum を使って、api-server を実装してみました。

### 対象読者

- rust で api-server を実装したい人
- rust で DDD を実装したい人

### 説明しないこと

- rust の基本的な文法
- DDD の基本的な考え方
- 使用クレートの使い方

## いざ、実装

### 仕様を決める

今回は、大学が、サークルを管理するシステムを作ることにしました。

- メンバーを追加できる
- メンバーを削除できる
- 4 年生は、追加できない
- 4 年生は、卒業する
- サークルは最低 3 人以上でないと、活動できない
- サークルは、最大人数が決まっている
- サークルには、代表者がいる
- 20 歳以上の人は、飲み会に参加できる
- 3 年生のみ、代表者になれる

### ドメインレイヤー

#### サークル集約

まずは、ドメインレイヤーから作成します。
サークル集約は、集約ルートになる `Circle` と、集約内のメンバーを表す `Member` の 2 つのエンティティから構成されます。

```rust
pub struct Circle {
    pub id: CircleId, // サークルのID (Value Object)
    pub name: String,
    pub capacity: usize,
    pub owner: Member,
    pub members: Vec<Member>,
}
```

```rust
pub struct Member {
    pub id: MemberId, // メンバーのID (Value Object)
    pub name: String,
    pub age: usize,
    pub grade: Grade,
    pub major: Major,
}
```

次に、集約に知識をあたえるために、メソッドを実装します。
rust では `impl` で `struct` にメソッドを実装します。

```rust
impl Circle {
    // サークルの新規作成メソッド
    pub fn new(name: String, owner: Member, capacity: usize) -> Result<Self, Error> {
        // オーナーは3年生のみなれる
        if owner.grade != Grade::Third {
            return Err(Error::msg("Owner must be 3rd grade"));
        }

        let mut gen = rand::thread_rng();
        let id = CircleId::new(gen.gen::<usize>());

        Ok(Circle {
            id,
            name,
            owner,
            capacity,
            members: vec![],
        })
    }

    // サークルの再構成メソッド
    pub fn reconstruct(
        id: CircleId,
        name: String,
        owner: Member,
        capacity: usize,
        members: Vec<Member>,
    ) -> Self {
        Circle {
            id,
            name,
            owner,
            capacity,
            members,
        }
    }

　　   // サークルの更新メソッド
    pub fn update(&mut self, name: Option<String>, capacity: Option<usize>) {
        if let Some(name) = name {
            self.name = name;
        }
        if let Some(capacity) = capacity {
            self.capacity = capacity;
        };
    }

    // サークルが満員かどうかを判定するメソッド
    pub fn is_full(&self) -> bool {
        self.members.len() + 1 >= self.capacity
    }

    // サークルが運営可能かどうかを判定するメソッド
    pub fn is_runnable(&self) -> bool {
        self.members.len() + 1 >= 3
    }

    // 飲み会に参加できるかどうかを判定するメソッド
    pub fn is_drinkable_alcohol(member: &Member) -> bool {
        member.is_adult()
    }

    // メンバーをサークルに追加するメソッド
    pub fn add_member(&mut self, member: Member) -> Result<(), String> {
        // 満員の場合はサークルに入れない
        if self.is_full() {
            return Err("Circle member is full".to_string());
        }

        // 4年生はサークルに入れない
        if member.grade == Grade::Fourth {
            return Err("4th grade can't join circle".to_string());
        }

        self.members.push(member);
        Ok(())
    }

    // メンバーをサークルから削除するメソッド
    pub fn remove_member(&mut self, member: &Member) -> Result<(), String> {
        // オーナーは削除できない
        if self.owner.id == member.id {
            return Err("Owner can't be removed".to_string());
        }
        self.members.retain(|m| m.id != member.id);
        Ok(())
    }

    // 4年生を卒業させるメソッド
    pub fn graduate(&mut self) {
        self.members.retain(|m| m.grade != Grade::Fourth);
    }
}
```

```rust
impl Member {
    // メンバーの新規作成メソッド
    pub fn new(name: String, age: usize, grade: Grade, major: Major) -> Self {
        let mut rng = rand::thread_rng();
        let id = MemberId::new(rng.gen::<usize>());
        Member {
            id,
            name,
            age,
            grade,
            major,
        }
    }

    // 20歳以上かどうかを判定するメソッド
    pub fn is_adult(&self) -> bool {
        self.age >= 20
    }
}
```

#### ポート

ドメインの振る舞いを外部に公開するためのポートを作成します。
サークル集約を操作するためのポートを作成します。
`find_circle_by_id` 以外は、成功時の戻り値を返却しません。

```rust
pub trait CircleRepositoryTrait {
    fn find_circle_by_id(&self, circle_id: &CircleId) -> Result<Circle, Error>;
    fn create(&mut self, circle: &Circle) -> Result<(), Error>;
    fn save(&mut self, circle: &Circle) -> Result<(), Error>;
    fn delete(&mut self, circle: &Circle) -> Result<(), Error>;
}
```

トレイトは、他の言語で言うところのインターフェースのようなものです。

### インフラストラクチャレイヤー

インフラストラクチャレイヤーは、永続化を担います。
永続化先は問いません。Firestore や Postgres など、なんでも良いです。
今回は、メモリに保存することにしました。

インフラストラクチャレイヤーでは、ドメインレイヤーのポートを実装します。

```rust
pub struct CircleRepository {
    db: Db,
}

impl CircleRepository {
    pub fn new() -> Self {
        Self { db: Db::new() }
    }
}

impl CircleRepositoryTrait for CircleRepository {
    fn find_circle_by_id(&self, circle_id: &CircleId) -> Result<Circle, Error> {
        match self.db.find(&circle_id.to_string()) {
            Some(circle) => Ok(Circle::reconstruct(
                circle.id.clone(),
                circle.name.clone(),
                circle.owner.clone(),
                circle.capacity,
                circle.members.clone(),
            )),
            None => Err(Error::msg("Circle not found")),
        }
    }

    fn create(&mut self, circle: &Circle) -> Result<(), Error> {
        match self.db.create(circle.clone()) {
            Some(_) => Ok(()),
            None => Err(Error::msg("Circle already exists")),
        }
    }

    fn save(&mut self, circle: &Circle) -> Result<(), Error> {
        match self.db.update(circle.clone()) {
            Some(_) => Ok(()),
            None => Err(Error::msg("Circle not found")),
        }
    }

    fn delete(&mut self, circle: &Circle) -> Result<(), Error> {
        match self.db.delete(&circle.id.to_string()) {
            Some(_) => Ok(()),
            None => Err(Error::msg("Circle not found")),
        }
    }
}
```

データベースから取得した値を、ドメインレイヤーのエンティティに変換するために、`reconstruct` メソッドを使っています。
今回は DB がメモリなので、あまり意味を感じにくいですが、アプリケーション層との依存をなくすのに有効です。
DB が突然、Firebase に変わっても、`reconstruct` で差分を吸収してくれるので、アプリケーション層には影響を与えません。
そのためにも、アプリケーション層がインフラストラクチャレイヤーに依存しないように抽象に依存させることが重要です。(後述します)

DB の実装は DDD にそれほど関係ないので、目を通す程度で大丈夫です。
::::details メモリ上に保存する DB の実装

```rust
use crate::domain::aggregate::circle::Circle;
use std::collections::HashMap;

#[derive(Clone)]
pub struct Db {
    db: HashMap<String, Circle>,
}

impl Db {
    pub fn new() -> Self {
        Self { db: HashMap::new() }
    }

    pub fn update(&mut self, circle: Circle) -> Option<Circle> {
        if self.is_registered(&circle.id.to_string()) {
            self.db.insert(circle.id.to_string(), circle)
        } else {
            None
        }
    }

    pub fn create(&mut self, circle: Circle) -> Option<Circle> {
        if self.is_registered(&circle.id.to_string()) {
            Some(circle)
        } else {
            self.db.insert(circle.id.to_string(), circle)
        }
    }

    pub fn find(&self, circle_id: &str) -> Option<&Circle> {
        self.db.get(circle_id)
    }

    pub fn delete(&mut self, circle_id: &str) -> Option<Circle> {
        self.db.remove(circle_id)
    }

    fn is_registered(&self, circle_id: &str) -> bool {
        self.db.contains_key(circle_id)
    }
}
```

::::

### アプリケーションレイヤー

アプリケーションレイヤーでは、ユースケースの実現のために、Entity や VO を使って、レポジトリー (インフラ層) に処理を依頼します。
レポジトリーに処理を依頼しますが、インフラ層には依存しません。
いわゆる、依存性逆転の原則を用いて、ユースケースを実現します。
実態ではなく、抽象に依存させるために、トレイトを使います。
今回は、サークルを作成するユースケースを実装します。

```rust
use anyhow::Result;
use serde::Deserialize;

use crate::domain::{
    aggregate::{
        circle::Circle,
        member::Member,
        value_object::{grade::Grade, major::Major},
    },
    repository::circle_repository_trait::CircleRepositoryTrait,
};

#[derive(Debug, Deserialize)]
pub struct CreateCircleInput {
    pub circle_name: String,
    pub capacity: usize,
    pub owner_name: String,
    pub owner_age: usize,
    pub owner_grade: usize,
    pub owner_major: String,
}

impl CreateCircleInput {
    pub fn new(
        circle_name: String,
        capacity: usize,
        owner_name: String,
        owner_age: usize,
        owner_grade: usize,
        owner_major: String,
    ) -> Self {
        CreateCircleInput {
            circle_name,
            capacity,
            owner_name,
            owner_age,
            owner_grade,
            owner_major,
        }
    }
}

pub struct CreateCircleUsecase<T>
where
    T: CircleRepositoryTrait,
{
    circle_repository: T,
}

impl<T> CreateCircleUsecase<T>
where
    T: CircleRepositoryTrait,
{
    pub fn new(circle_repository: T) -> Self {
        CreateCircleUsecase { circle_repository }
    }

    pub fn execute(&mut self, circle_circle_input: CreateCircleInput) -> Result<()> {
        let grade = match circle_circle_input.owner_grade {
            1 => Grade::First,
            2 => Grade::Second,
            3 => Grade::Third,
            4 => Grade::Fourth,
            _ => unimplemented!("error"),
        };

        let major = match circle_circle_input.owner_major.as_str() {
            "ComputerScience" => Major::ComputerScience,
            "Economics" => Major::Economics,
            "Law" => Major::Law,
            "Art" => Major::Art,
            "Music" => Major::Music,
            _ => Major::Other,
        };
        let owner = Member::new(
            circle_circle_input.owner_name,
            circle_circle_input.owner_age,
            grade,
            major,
        );
        let circle = Circle::new(
            circle_circle_input.circle_name,
            owner,
            circle_circle_input.capacity,
        )?;
        self.circle_repository.create(&circle)
    }
}

```

ひとつひとつ見ていきます。

1. CreateCircleUsecase 構造体
   CreateCircleUsecase はジェネリクス構造体です。フィールドには、CircleRepositoryTrait トレイトを実装したものを受け取ります。

2. impl CreateCircleUsecase
   CreateCircleUsecase の構造体に対して、２つメソッド、`new` と `execute` を実装します。

   - new メソッド
     インスタンスを生成するためのメソッドです。CircleRepositoryTrait トレイトを実装したものを受け取ります。
     他の言語で言うところのコンストラクターです。ここに、依存性注入を行います。実態ではなく、抽象(トレイト)を設定することで、依存性逆転の原則を実現します。

   - execute メソッド
     ユースケースを実行するためのメソッドです。CreateCircleInput を受け取り、Circle Entity を作成し、レポジトリーに保存します。
     self とは、CreateCircleUsecase の自身を指します。今回はフィールドが１つしかないので、`self.circle_repository` でフィールドにアクセスでき、そのフィールドが、CircleRepositoryTrait トレイトを実装していることが保証されているため、`create` メソッドを呼び出すことができます。

これで、ユースケースはドメインのみに依存し、インフラストラクチャレイヤーに依存しないように実装できました。

### プレゼンテーションレイヤー

プレゼンテーションレイヤーでは、エンドポイントの定義、リクエストの受け取り、アプリケーション層に渡す値のマッピングを行います。
他のフレームワークだと、コントローラーのようなものです。

```rust
#[derive(Clone)]
struct AppState {}

#[tokio::main]
async fn main() -> Result<(), ()> {
    let app = Router::new()
        .route("/circle/:id", get(handle_fetch_circle))
        .route("/circle", post(handle_create_circle))
        .route("/circle/:id", put(handle_update_circle))
        .with_state(AppState {});

    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();
    println!("Listening on: {}", listener.local_addr().unwrap());
    axum::serve(listener, app).await.unwrap();
    Ok(())
}

pub async fn handle_create_circle(Query(param): Query<CreateCircleInput>) -> impl IntoResponse {
    let circle_circle_input = CreateCircleInput::new(
        param.circle_name,
        param.capacity,
        param.owner_name,
        param.owner_age,
        param.owner_grade,
        param.owner_major,
    );
    let mut usecase = CreateCircleUsecase::new(CircleRepository::new());
    usecase
        .execute(circle_circle_input)
        .map_err(|e| e.to_string())
}

```

エンドポイントは３つありますが、今回は、サークルを作成するエンドポイントのみに注目してください。
CreateCircleInput は、リクエストのボディを受け取るための構造体です。
今回は、引数で受け取ったものを、そのまま使って、CreateCircleInput を構築しています。

そして、CreateCircleUsecase に、レポジトリの struct を注入しています。DI 的なことを実現してます。
注入できるのは、CircleRepositoryTrait トレイトを実装したものだけです。

usecase に対して、execute メソッドを呼び出すことで、ユースケースを実行します。

## 依存の方向

![依存関係](/images/dependency-ddd.png)
今回のアーキテクチャの依存関係は、上記のようになります。
インフラストラクチャレイヤーと、アプリケーションレイヤーの依存ないことが重要です。

## まとめ

rust と DDD を使って、api-server を実装してみました。rust はまだまだ、業務での採用が少ないですが、バックエンドをはじめに盛り上がってくると思うので、ぜひ、使ってみてください。
今回のソースコードは、[こちら](https://github.com/katayama8000/ddd-rust) にあります。

## We are hiring! 👨‍💻👩‍💻

ドクターメイトではエンジニアを積極採用しています！
医療介護業界に興味のある方、Rust に興味のある方、カジュアルにお話しましょう！

https://dazzling-fireplace-74e.notion.site/559d8c392ca643b78355064c00421270
https://dazzling-fireplace-74e.notion.site/dazzling-fireplace-74e/Engineer-Entrance-Book-a785dcd553224d70b7b7daae12bb02f5
